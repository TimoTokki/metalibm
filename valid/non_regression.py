# -*- coding: utf-8 -*-

import argparse
import sys
import re

# import meta-function script from metalibm_functions directory
import metalibm_functions.ml_log10
import metalibm_functions.ml_log1p
import metalibm_functions.ml_log2
import metalibm_functions.ml_log
import metalibm_functions.ml_exp
import metalibm_functions.ml_cbrt
import metalibm_functions.ml_vectorizable_log
import metalibm_functions.ml_cosh

from metalibm_core.core.ml_formats import ML_Binary32, ML_Binary64, ML_Int32
from metalibm_core.targets.common.vector_backend import VectorBackend

from valid.test_utils import *

# list of non-regression tests
# details on NewSchemeTest object can be found in valid.test_utils module
#   Each object requires a title, a function constructor and a list
#   of test cases (each is a dictionnary of parameters -> values)
new_scheme_function_list = [
  NewSchemeTest(
    "basic hyperbolic cosine gen test",
    metalibm_functions.ml_cosh.ML_HyperbolicCosine,
    [{"precision": ML_Binary32}, {"precision": ML_Binary64}]
  ),
  NewSchemeTest(
    "auto test hyperbolic cosine",
    metalibm_functions.ml_cosh.ML_HyperbolicCosine,
    [{"function_name": "my_cosh", "precision": ML_Binary32, "auto_test": 100, "auto_test_execute": 100}, 
    {"function_name": "my_cosh", "precision": ML_Binary64, "auto_test": 100, "auto_test_execute": 100}, 
    ]
  ),
  NewSchemeTest(
    "basic log test",
    metalibm_functions.ml_log.ML_Log,
    [{"precision": ML_Binary32}, {"precision": ML_Binary64}]
  ), 
  NewSchemeTest(
    "basic log1p test",
    metalibm_functions.ml_log1p.ML_Log1p,
    [{"precision": ML_Binary32}, {"precision": ML_Binary64}]
  ), 
  NewSchemeTest(
    "basic log2 test",
    metalibm_functions.ml_log2.ML_Log2,
    [{"precision": ML_Binary32}, {"precision": ML_Binary64}]
  ), 
  NewSchemeTest(
    "basic log10 test",
    metalibm_functions.ml_log10.ML_Log10,
    [{"precision": ML_Binary32}, {"precision": ML_Binary64}]
  ), 
  NewSchemeTest(
    "basic exp test",
    metalibm_functions.ml_exp.ML_Exponential,
    [{"precision": ML_Binary32}, {"precision": ML_Binary64}]
  ), 
  NewSchemeTest(
    "auto execute exp test",
    metalibm_functions.ml_exp.ML_Exponential,
    [{"precision": ML_Binary32, "function_name": "my_exp", "auto_test": 100, "auto_test_execute": 100},
    ]
  ), 
  NewSchemeTest(
    "basic cubic square test",
    metalibm_functions.ml_cbrt.ML_Cbrt,
    [{"precision": ML_Binary32}, {"precision": ML_Binary64}]
  ), 
  NewSchemeTest(
    "basic vectorizable log scalar test",
    metalibm_functions.ml_vectorizable_log.ML_Log,
    [
      {"precision": ML_Binary32}, 
     # disabled pending bugfix
     #  {"precision": ML_Binary64}, 
    ]
  ), 
  NewSchemeTest(
    "vector exp test",
    metalibm_functions.ml_exp.ML_Exponential,
    [{"precision": ML_Binary32, "vector_size": 2, "target": VectorBackend()}, ]
  ), 
]

test_tag_map = {}
for test in new_scheme_function_list:
  test_tag_map[test.get_tag_title()] = test

## Command line action to set break on error in load module
class ListTestAction(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        for test in  new_scheme_function_list:
          print test.get_tag_title()
        exit(0)

# generate list of test object from string 
# of comma separated test's tag
def parse_test_list(test_list):
  test_tags = test_list.split(",")
  return [test_tag_map[tag] for tag in test_tags]

arg_parser = argparse.ArgumentParser(" Metalibm non-regression tests")
# enable debug mode
arg_parser.add_argument("--debug", dest = "debug", action = "store_const", 
                        default = False, const = True, 
                        help = "enable debug mode")
# listing available tests
arg_parser.add_argument("--list", action = ListTestAction, help = "list available test", nargs = 0) 

# select list of tests to be executed
arg_parser.add_argument("--execute", dest = "test_list", type = parse_test_list, default = new_scheme_function_list, help = "list of comma separated test to be executed") 

arg_parser.add_argument("--match", dest = "match_regex", type = str, default = ".*", help = "list of comma separated match regexp to be used for test selection") 




args = arg_parser.parse_args(sys.argv[1:])

success = True
# list of TestResult objects generated by execution
# of new scheme tests
result_details = []

for test_scheme in args.test_list:
  if re.search(args.match_regex, test_scheme.get_tag_title()) != None:
    test_result = test_scheme.perform_all_test(debug = args.debug)
    result_details.append(test_result)
    if not test_result.get_result(): 
      success = False

# Printing test summary for new scheme
for result in result_details:
  print result.get_details()

if success:
  print "OVERALL SUCCESS"
  exit(0)
else:
  print "OVERALL FAILURE"
  exit(1)
