# -*- coding: utf-8 -*-

import argparse
import sys
import re

from sollya import Interval

# import meta-function script from metalibm_functions directory
import metalibm_hw_blocks.lzc
import metalibm_hw_blocks.ml_fp_adder
import metalibm_hw_blocks.ml_fp_mpfma
import metalibm_hw_blocks.ml_fixed_mpfma
import metalibm_hw_blocks.ml_fp_div

from metalibm_core.core.ml_formats import  \
  ML_Binary16, ML_Binary32, ML_Binary64, ML_Int32

from metalibm_core.utility.ml_template import (
    target_instanciate, DefaultEntityArgTemplate
)

from valid.test_utils import *

class EntitySchemeTest(NewSchemeTest):
  ## Build an argument template from dict
  def build_arg_template(self, **kw):
    default_arg = self.ctor.get_default_args(**kw)
    return default_arg

# list of non-regression tests
# details on NewSchemeTest object can be found in valid.test_utils module
#   Each object requires a title, a function constructor and a list
#   of test cases (each is a dictionnary of parameters -> values)
new_scheme_function_list = [
  EntitySchemeTest(
    "basic Leading Zero Count",
    metalibm_hw_blocks.lzc.ML_LeadingZeroCounter,
    [{"width": 32}, {"width": 13},]
  ),
  EntitySchemeTest(
    "basic floating-point adder",
    metalibm_hw_blocks.ml_fp_adder.FP_Adder,
    [{"precision": ML_Binary32}, {"precision": ML_Binary64},]
  ),
  EntitySchemeTest(
    "mixed-precision fused multiply-add",
    metalibm_hw_blocks.ml_fp_mpfma.FP_MPFMA,
    [
    {},
    {"precision": ML_Binary16, "acc_precision": ML_Binary32}],
  ),
  EntitySchemeTest(
    "fixed-point accumulation MPFMA",
    metalibm_hw_blocks.ml_fixed_mpfma.FP_FIXED_MPFMA,
    [
      {},
      {"precision": ML_Binary16, "extra_digits": 16},
      {"precision": ML_Binary16, "extra_digits": 16, "sign_magnitude": True},
      {"precision": ML_Binary16, "extra_digits": 16, "pipelined": True},
    ],
  ),
  EntitySchemeTest(
    "floating-point division",
    metalibm_hw_blocks.ml_fp_div.FP_Divider,
    [
        {},
    ]
  ),
]

test_tag_map = {}
for test in new_scheme_function_list:
  test_tag_map[test.get_tag_title()] = test

## Command line action to set break on error in load module
class ListTestAction(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        for test in  new_scheme_function_list:
          print test.get_tag_title()
        exit(0)

# generate list of test object from string 
# of comma separated test's tag
def parse_test_list(test_list):
  test_tags = test_list.split(",")
  return [test_tag_map[tag] for tag in test_tags]

arg_parser = argparse.ArgumentParser(" Metalibm non-regression tests")
# enable debug mode
arg_parser.add_argument("--debug", dest = "debug", action = "store_const", 
                        default = False, const = True, 
                        help = "enable debug mode")
# listing available tests
arg_parser.add_argument("--list", action = ListTestAction, help = "list available test", nargs = 0) 

# select list of tests to be executed
arg_parser.add_argument("--execute", dest = "test_list", type = parse_test_list, default = new_scheme_function_list, help = "list of comma separated test to be executed") 

arg_parser.add_argument("--match", dest = "match_regex", type = str, default = ".*", help = "list of comma separated match regexp to be used for test selection") 




args = arg_parser.parse_args(sys.argv[1:])

success = True
# list of TestResult objects generated by execution
# of new scheme tests
result_details = []

for test_scheme in args.test_list:
  if re.search(args.match_regex, test_scheme.get_tag_title()) != None:
    test_result = test_scheme.perform_all_test(debug = args.debug)
    result_details.append(test_result)
    if not test_result.get_result(): 
      success = False

# Printing test summary for new scheme
for result in result_details:
  print result.get_details()

if success:
  print "OVERALL SUCCESS"
  exit(0)
else:
  print "OVERALL FAILURE"
  exit(1)
