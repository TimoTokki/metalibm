# -*- coding: utf-8 -*-

import sys

from pythonsollya import *

from core.attributes import ML_Debug
from core.ml_operations import *
from core.ml_formats import *
from code_generation.c_code_generator import CCodeGenerator
from code_generation.generic_processor import GenericProcessor
from code_generation.code_object import CodeObject, CodeFunction
from code_generation.generator_utility import C_Code 
from core.ml_optimization_engine import OptimizationEngine
from core.polynomials import *
from core.ml_table import ML_Table

from kalray_proprietary.k1a_processor import K1A_Processor
from kalray_proprietary.k1b_processor import K1B_Processor
from code_generation.x86_processor import X86_FMA_Processor, X86_SSE_Processor
from code_generation.gappa_code_generator import GappaCodeGenerator

from utility.gappa_utils import execute_gappa_script_extract
from ml_functions.ml_template import ML_ArgTemplate

from utility.common import test_flag_option, extract_option_value  


class ML_FFT:
    def __init__(self, 
                 precision = ML_Binary32, 
                 abs_accuracy = S2**-24, 
                 libm_compliant = True, 
                 debug_flag = False, 
                 fuse_fma = True, 
                 num_iter = 3,
                 fast_path_extract = True,
                 target = GenericProcessor(), 
                 output_file = "__divsf3.c", 
                 function_name = "__divsf3"):
        # declaring CodeFunction and retrieving input variable
        self.precision = precision
        self.function_name = function_name
        exp_implementation = CodeFunction(self.function_name, output_format = precision)


	# input variables
	xr = []
	xi = []
	for i in xrange(4):
	    xr.append(exp_implementation.add_input_variable("x%dr" % i, self.precision))
	    xi.append(exp_implementation.add_input_variable("x%di" % i, self.precision))
	    input_list += [xr[i], xi[i]]

	for input in input_list: input.set_interval(Interval(0, 1))

	wr = exp_implementation.add_input_variable("wr", precision)
	wi = exp_implementation.add_input_variable("wi", precision)
	wr.set_interval(Interval(-1, 1))
	wi.set_interval(Interval(-1, 1))


	b0r_ex = (xr[0] + xr[1]) + (xr[2] + xr[3])                                                                                                        
	b0i_ex = (xi[0] + xi[1]) + (xi[2] + xi[3])                                                                                                        
	res0r_ex = b0r_ex * wr - b0i_ex * wi                                                                                                        
	res0i_ex = b0i_ex * wr + b0r_ex * wi   


	b0r_ex.set_tag("b0r")
        b0i_ex.set_tag("b0i")
	res0r_ex.set_tag("res0r")
	res0i_ex.set_tag("res0i")

	result = res0r_ex 

	scheme = Statement(Return(result))


        processor = target

        opt_eng = OptimizationEngine(processor)

        # fusing FMA
        if 1:
            print "MDL fusing FMA"
            scheme = opt_eng.fuse_multiply_add(scheme, silence = True)

        print "MDL abstract scheme"
        opt_eng.instantiate_abstract_precision(scheme, None)


        print "MDL instantiated scheme"
        opt_eng.instantiate_precision(scheme, default_precision = self.precision)


        print "subexpression sharing"
        opt_eng.subexpression_sharing(scheme)

        print "silencing operation"
        opt_eng.silence_fp_operations(scheme)

        # registering scheme as function implementation
        exp_implementation.set_scheme(scheme)

        # check processor support
        opt_eng.check_processor_support(scheme)

        # factorizing fast path
        opt_eng.factorize_fast_path(scheme)
        
        cg = CCodeGenerator(processor, declare_cst = False, disable_debug = not debug_flag, libm_compliant = libm_compliant)
        self.result = exp_implementation.get_definition(cg, C_Code, static_cst = True)
        self.result.add_header("math.h")
        self.result.add_header("stdio.h")
        self.result.add_header("inttypes.h")
        self.result.add_header("support_lib/ml_special_values.h")

        output_stream = open(output_file, "w")
        output_stream.write(self.result.get(cg))
        output_stream.close()

	var_copy_map = {}
	for input_var in input_list:
	  var_copy_map[input_var] = Variable(input_var.get_tag(), precision = self.precision, interval = Interval(0, 1))
	var_copy_map[wr] = Variable("wr", precision = self.precision, interval = Interval(-1, 1))
	var_copy_map[wi] = Variable("wi", precision = self.precision, interval = Interval(-1, 1))

        gappacg = GappaCodeGenerator(target, declare_cst = False, disable_debug = True)
	eval_error = gappacg.get_eval_error_v2(opt_eng, result.get_handle().get_node(), var_copy_map)

        print "eval_error: ", eval_error



if __name__ == "__main__":
    # auto-test
    num_iter        = int(extract_option_value("--num-iter", "3"))

    arg_template = ML_ArgTemplate()
    arg_template.sys_arg_extraction()


    ml_div          = ML_FFT(arg_template.precision, 
                                  libm_compliant            = arg_template.libm_compliant, 
                                  debug_flag                = arg_template.debug_flag, 
                                  target                    = arg_template.target, 
                                  fuse_fma                  = arg_template.fuse_fma, 
                                  fast_path_extract         = arg_template.fast_path,
                                  num_iter                  = num_iter,
                                  function_name             = arg_template.function_name,
                                  output_file               = arg_template.output_file)
